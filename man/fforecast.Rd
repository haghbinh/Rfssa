% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fforecast.R
\name{fforecast}
\alias{fforecast}
\title{Functional Singular Spectrum Analysis Recurrent Forecasting and Vector Forecasting}
\usage{
fforecast(U, groups = list(1), h = 1, method = "recurrent", tol = 10^-3)
}
\arguments{
\item{U}{An object of class \code{\link{fssa}} that holds the decomposition.}

\item{groups}{A list of numeric vectors where each vector includes indices of elementary components of a group used for reconstruction and forecasting.}

\item{h}{An integer that specifies the forecast horizon.}

\item{method}{A character string specifying the type of forecasting to perform either \code{"recurrent"} or \code{"vector"}.}

\item{tol}{A double specifying the amount of tolerated error in the approximation of the matrix that corresponds with the operator formed using a Neumann series leveraged in both forecasting algorithms.}
}
\value{
A list of objects of class \code{\link{fts}} where each fts corresponds to a forecasted group.
}
\description{
This function performs functional singular spectrum analysis (FSSA) recurrent forecasting (FSSA R-forecasting) or vector forecasting (FSSA V-forecasting) of univariate or multivariate functional time series (\code{\link{fts}}) observed over a one-dimensional domain.
}
\examples{
\dontrun{
data("Callcenter")
L <- 28
U <- fssa(Callcenter, L)
groups <- list(1,1:7)
## Perform FSSA R-forecast
pr_R <- fforecast(U = U, groups = groups, h = 30, method = "recurrent")

plotly_funts(pr_R[[1]], main = "Call Center Mean Component Recurrent Forecast",
             xlab = "Time (6 minutes aggregated)",
             ylab = "Sqrt of Call Numbers",type="line",
             xticklabels = list(c("00:00","06:00","12:00","18:00","24:00")),xticklocs =
               list(c(1,60,120,180,240)))
plotly_funts(pr_R[[2]], main = "Call Center Recurrent Forecast from 7'th first components",
             xlab = "Time (6 minutes aggregated)",
             ylab = "Sqrt of Call Numbers",type="line",
             xticklabels = list(c("00:00","06:00","12:00","18:00","24:00")),xticklocs =
               list(c(1,60,120,180,240)))


## Perform FSSA V-forecast
pr_V <- fforecast(U = U, groups = groups, h = 30, method = "vector", tol = 10^-3)

plotly_funts(pr_V[[1]], mains = "Call Center Mean Component Vector Forecast",
     xlabels = "Time (6 minutes aggregated)",
     ylabels = "Sqrt of Call Numbers",type="line",
     xticklabels = list(c("00:00","06:00","12:00","18:00","24:00")),xticklocs =
       list(c(1,60,120,180,240)))
plotly_funts(pr_V[[2]], mains = "Call Center Vector Forecast from 7'th first components",
     xlabels = "Time (6 minutes aggregated)",
     ylabels = "Sqrt of Call Numbers",type="line",
     xticklabels = list(c("00:00","06:00","12:00","18:00","24:00")),xticklocs =
       list(c(1,60,120,180,240)))

# Multivariate forecasting example:
data("Montana")
L <- 45
time <- Montana$time
grid <- list(0:23, list(1:33, 1:33))
montana <- eval.funts(Montana, argvals = grid)
montana[[2]] <- array(
  scale(montana[[2]][, , ],
    center = min(montana[[2]][, , ]),
    scale = max(montana[[2]][, , ]) - min(montana[[2]][, , ])
  ),
  dim = c(33, 33, 133)
)
## Kernel density estimation of pixel intensity
NDVI <- matrix(NA, nrow = 512, ncol = 133)
for (i in 1:133) NDVI[, i] <- (density(montana[[2]][, , i], from = 0, to = 1)$y)

## Define functional objects
bs1 <- Montana$basis[[1]]

require(fda)
bs2 <- create.bspline.basis(nbasis = 15)
Y <- funts(X = list(montana[[1]], NDVI), basisobj = list(bs1, bs2))

plotly_funts(Y,
  main = c("Temperature", "NDVI"),
  xlab = c("Temperature", "NDVI"),
  ylab = c("Temperature", "NDVI Density"),
  xticklocs = list(c(0, 6, 12, 18, 23), seq(1, 512, len = 9)),
  xticklabels = list(c(0, 6, 12, 18, 23), seq(0, 1, len = 9))
)

U <- fssa(Y = Y, L = 45)
plotly_funts(U$Lsingf[[1]])
plot(U$Lsingf[[2]])

groups <- list(1, 1:3)
pr_R <- fforecast(U = U, groups = groups, h = 10, method = "recurrent")
plotly_funts(pr_R[[1]])
plotly_funts(pr_R[[2]])

pr_V <- fforecast(U = U, groups = groups, h = 10, method = "vector")
plot(pr_V[[1]])
plot(pr_V[[2]])
}

}
